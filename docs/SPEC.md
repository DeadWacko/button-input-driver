# ButtonLib SPEC (RP2040 Button Library)

**Name:** ButtonLib  
**Target:** RP2040 (и совместимые MCU)  
**Version:** 3.1.0  
**Author:** Wacko

---

## 1. Цели библиотеки

1. Обеспечить удобную и надёжную обработку физических кнопок:
   - антидребезг,
   - мульти-клик (single / double / triple),
   - длинное нажатие и удержание (auto-repeat),
   - комбинации кнопок (через suppression).
2. Изолировать обработку кнопок от конкретного железа:
   - библиотека не знает про GPIO / Pico SDK / HAL.
   - доступ к железу — только через коллбэк `read_fn`.
3. Быть дружелюбной к RT-системам:
   - никакого динамического выделения памяти;
   - работа в одном периодическом вызове `btn_update()`.

---

## 2. Область применения и ограничения

### 2.1. Область применения

- Мелкие устройства на RP2040: часы, меню, настройки, UI.
- Любые кнопки, подключённые:
  - напрямую к GPIO,
  - через ШИФР-регистры, I2C-экспандеры, тач-сенсоры и т.д.

### 2.2. Ограничения

- Библиотека предполагает периодический вызов `btn_update()`:
  - рекомендуемый интервал: **1–10 мс**;
  - допустимый максимум: до 20 мс (с падением точности таймингов).
- Время основано на счётчике в микросекундах (`uint64_t now_us`),
  обычно — `time_us_64()` из Pico SDK.

---

## 3. Термины

- **Raw state** — сырое состояние, сразу после `read_fn`.
- **Logic state** (`logic_state`) — состояние после антидребезга.
- **Press** — переход из `false` → `true` (BTN_EVT_DOWN).
- **Release** — переход из `true` → `false` (BTN_EVT_UP).
- **Click** — короткое нажатие/отпускание, не дотянувшее до `long_press_ms`.
- **Long press** — удержание дольше `long_press_ms`.
  - начало: BTN_EVT_LONG_START;
  - продолжение: серия BTN_EVT_LONG_HOLD с периодом `repeat_period_ms`.

---

## 4. API

### 4.1. Конфигурация кнопки (`btn_config_t`)

Поля:

- `id` — уникальный ID кнопки.
- `active_low` — `true`, если кнопка замыкает на GND.
- `read_fn(void *arg)` — чтение сырое состояния:
  - возвращает `true`, если кнопка **электрически активна**;
  - если `active_low == true`, инверсия делается внутри библиотеки.
- `hw_arg` — аргумент, передающийся в `read_fn`.
- `callback` — необязательный коллбэк на событие:
  - если вернул `true` — событие **поглощено** и не попадёт в очередь;
  - если `false` — событие будет положено в очередь.
- `cb_user_data` — пользовательский контекст для `callback`.
- Тайминги (мс):
  - `debounce_ms` — антидребезг.
  - `click_timeout_ms` — окно для мульти-клика.
  - `long_press_ms` — порог длинного нажатия.
  - `repeat_period_ms` — период авто-повтора (`0` = повтор выключен).

### 4.2. Состояние кнопки (`btn_state_t`)

Внутренний объект, полностью управляется библиотекой.
Пользователь обязан лишь:
- выделить память под `btn_state_t`,
- передать указатель в `btn_setup()`.

Состояние содержит:
- `raw_state`, `logic_state`;
- `suppressed` — подавление событий (для комбо);
- все временные метки (`state_start_time`, `last_release_time`, `last_repeat_time`);
- `click_count` — счётчик кликов / флаг long-press;
- `hold_repeat_count` — количество срабатываний `LONG_HOLD` в текущем удержании.

### 4.3. Контекст (`btn_context_t`)

Контекст системы кнопок. Хранит:
- массив `btn_instance_t` (конфиг+состояние на кнопку),
- очередь событий,
- индексы `head/tail`.

---

## 5. События и их семантика

Типы:

```c
typedef enum {
    BTN_EVT_DOWN,
    BTN_EVT_UP,
    BTN_EVT_CLICK,      // один или более коротких кликов
    BTN_EVT_LONG_START, // один раз на долговом удержании
    BTN_EVT_LONG_HOLD   // периодически при удержании (auto-repeat)
} btn_event_type_t;
````

Поле `clicks`:

* Для `BTN_EVT_CLICK` — количество кликов в серии:

  * 1 → одиночный клик;
  * 2 → двойной;
  * 3 → тройной;
* Для `BTN_EVT_LONG_HOLD` — номер повтора (1, 2, 3, ...).
* Для `BTN_EVT_DOWN / UP / LONG_START` — всегда `0`.

Гарантируется:

* Событие `BTN_EVT_LONG_START` генерируется **однократно** за удержание.
* Если длина нажатия превысила `long_press_ms`, короткий `CLICK` **не генерируется**.
* После длинного удержания:

  * `click_count` сбрасывается;
  * последующие короткие нажатия снова дают `CLICK`.

---

## 6. Поведение suppression / комбо

`btn_suppress_events(ctx, btn_id)`:

* устанавливает `suppressed = true`;
* обнуляет `click_count` и `hold_repeat_count`;
* предотвращает генерацию событий:

  * уже накопленных `CLICK`,
  * и всех будущих, пока не произойдёт **новое нажатие** (`BTN_EVT_DOWN`).

Типичный сценарий использования:

1. Пользователь зажал комбинацию, например L+R.
2. По таймауту комбинации:

   * вызываем `btn_suppress_events(ctx, ID_L)` и `btn_suppress_events(ctx, ID_R)`;
   * выполняем действие комбо (lock/menu/reset).

---

## 7. Очередь событий

* Фиксированного размера (`queue_size`).
* Реализация: кольцевой буфер.
* При переполнении:

  * новое событие **не теряется**;
  * старое самое дальнее по времени выталкивается вперёд (`tail`).

Это гарантирует, что самые свежие события всегда доступны.

---

## 8. Требования к вызовам `btn_update()`

* Функцию `btn_update(ctx, now_us)` необходимо вызывать:

  * либо из основного цикла через константную задержку,
  * либо из периодического таймера.

Рекомендуемые параметры:

* Период вызова: 1–10 мс.
* Дребезг `debounce_ms`: 10–50 мс.
* Таймаут клика `click_timeout_ms`: 150–400 мс.
* Длинное нажатие `long_press_ms`: 500–1500 мс.
* Период повтора `repeat_period_ms`: 50–200 мс.

---

## 9. Потокобезопасность и ограничения

* Библиотека рассчитана на вызов **из одного потока/ядра**.
* Если используется в SMP / с ISR:

  * весь доступ к `btn_context_t` должен быть сериализован снаружи;
  * сами функции библиотеки не используют mutex/spinlock.

---

## 10. Пример использования

См. `examples/main.c` в репозитории:

* настройка трёх кнопок (Left/Center/Right),
* интеграция в меню,
* использование `BTN_EVT_CLICK`, `BTN_EVT_LONG_START`, `BTN_EVT_LONG_HOLD`.